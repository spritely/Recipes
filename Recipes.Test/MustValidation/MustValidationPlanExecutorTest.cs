// --------------------------------------------------------------------------------------------------------------------
// <copyright file="MustValidationPlanExecutorTest.cs">
//   Copyright (c) 2017. All rights reserved.
//   Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Spritely.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Recipes.Test
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using FluentAssertions;
    using NUnit.Framework;

    // See MustExtensions.cs for comments on type definitions
    using GetArguments = System.Func<System.Collections.Generic.IEnumerable<System.Tuple<System.Type, string, object>>>;
    using Rule = System.Tuple<System.Func<System.Type, object, bool>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Type, System.Collections.Generic.IEnumerable<string>, object, string, System.Exception>>;
    using ValidationReport = System.Collections.Generic.IEnumerable<System.Tuple<System.Type, string, object, bool, System.Collections.Generic.IEnumerable<string>, System.Func<System.Type, System.Collections.Generic.IEnumerable<string>, object, string, System.Exception>>>;

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "There probably is a way to do this better but currently the tests are organized first by pattern of the call and then by the method under test which makes it easier to think about but harder to separate - maybe later.")]
    [TestFixture]
    public class MustValidationPlanExecutorTest
    {
        [Test]
        public void Report_throws_on_null_validation_plan_argument()
        {
            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).Report());
        }

        [Test]
        public void Report_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.Report().ToList());
        }

        [Test]
        public void OrRunWithAll_function_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(
                validationPlan => validationPlan.OrRunWithAll(exceptions => "ignored"));
        }

        [Test]
        public void OrRunWithAll_action_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrRunWithAll(exceptions => { }));
        }

        [Test]
        public void OrRunWith_function_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(
                validationPlan => validationPlan.OrRunWith(exception => "ignored"));
        }

        [Test]
        public void OrRunWith_action_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrRunWith(exception => { }));
        }

        [Test]
        public void OrRun_function_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrRun(() => "ignored"));
        }

        [Test]
        public void OrRun_action_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrRun(() => { }));
        }

        [Test]
        public void OrThrowWithAll_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(
                validationPlan => validationPlan.OrThrowWithAll(exceptions => null));
        }

        [Test]
        public void OrThrowWith_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrThrowWith(exception => null));
        }

        [Test]
        public void OrThrow_function_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrThrow(() => null));
        }

        [Test]
        public void OrThrowOfT_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(
                validationPlan => validationPlan.OrThrow<InvalidOperationException>());
        }

        [Test]
        public void OrThrow_calls_correct_validation_functions()
        {
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_calls_correct_validation_functions()
        {
            // Test asserts multiple validations are callsed since all the rules pass
            AssertCorrectValidationFunctionsAreCalled(validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void AssertCorrectValidationFunctionsAreCalled(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = null as object;
            var arg2 = null as string;
            var arg3 = null as int?;
            var times1 = 0;
            var times2 = 0;
            var times3 = 0;

            var testRule1 = MakeRule.That<object>(
                v =>
                {
                    times1++;
                    return true;
                }).OrCreateArgumentException();

            var testRule2 = MakeRule.That<string>(
                v =>
                {
                    times2++;
                    return true;
                }).OrCreateArgumentException();

            var testRule3 = MakeRule.That<int?>(
                v =>
                {
                    times3++;
                    return true;
                }).OrCreateArgumentException();

            var validationPlan = new { arg1, arg2, arg3 }.Must(testRule1, testRule2, testRule3);
            runTest(validationPlan);

            times1.Should().Be(3);
            times2.Should().Be(1);
            times3.Should().Be(1);
        }

        [Test]
        public void Report_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(validationPlan => validationPlan.Report().ToList());
        }

        [Test]
        public void OrRunWithAll_function_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrRunWithAll(exceptions => "ignored"));
        }

        [Test]
        public void OrRunWithAll_action_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrRunWithAll(exceptions => { }));
        }

        [Test]
        public void OrRunWith_function_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrRunWith(exception => "ignored"));
        }

        [Test]
        public void OrRunWith_action_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrRunWith(exception => { }));
        }

        [Test]
        public void OrRun_function_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrRun(() => "ignored"));
        }

        [Test]
        public void OrRun_action_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(validationPlan => validationPlan.OrRun(() => { }));
        }

        [Test]
        public void OrThrowWithAll_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrThrowWithAll(exceptions => null));
        }

        [Test]
        public void OrThrowWith_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrThrowWith(exception => null));
        }

        [Test]
        public void OrThrow_function_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrThrow(() => null));
        }

        [Test]
        public void OrThrowOfT_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(
                validationPlan => validationPlan.OrThrow<InvalidOperationException>());
        }

        [Test]
        public void OrThrow_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_calls_validation_functions_with_expected_arguments()
        {
            AssertValidationFunctionsAreCalledWithExpectedArguments(validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void AssertValidationFunctionsAreCalledWithExpectedArguments(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "test";
            var arg2 = 1.5;
            var arg3 = null as int?;
            var actualStringValue = string.Empty;
            var actualDoubleValue = 0.0;
            int? actualIntValue = -1;

            var testRule1 = MakeRule.That<string>(
                v =>
                {
                    actualStringValue = v;
                    return true;
                }).OrCreateArgumentException();

            var testRule2 = MakeRule.That<double>(
                v =>
                {
                    actualDoubleValue = v;
                    return true;
                }).OrCreateArgumentException();

            var testRule3 = MakeRule.That<int?>(
                v =>
                {
                    actualIntValue = v;
                    return true;
                }).OrCreateArgumentException();

            var validationPlan = new { arg1, arg2, arg3 }.Must(testRule1, testRule2, testRule3);
            runTest(validationPlan);

            actualStringValue.Should().Be("test");
            actualDoubleValue.Should().Be(1.5);
            actualIntValue.Should().Be(null);
        }

        [Test]
        public void Report_returns_expected_results()
        {
            var arg1 = new object();
            var arg2 = 1.5;
            var arg3 = "test";

            var alwaysBeTrue = MakeRule.That<object>(o => true).OrCreateArgumentException();
            var alwaysBeFalse = MakeRule.That<string>(s => false).OrCreateArgumentException().Because("Test");

            var report = new { arg1, arg2, arg3 }.Must(alwaysBeTrue, alwaysBeFalse).Report().ToList();

            report.Should().HaveCount(6); // all combinations
            report.First().Item1.Should().Be(typeof(object));
            report.First().Item2.Should().Be("arg1");
            report.First().Item3.Should().Be(arg1);
            report.First().Item4.Should().BeTrue();
            report.First().Item5.Should().BeEmpty();
            report.First().Item6.Should().BeSameAs(alwaysBeTrue.Item3);
            report.Skip(1).First().Item1.Should().Be(typeof(object));
            report.Skip(1).First().Item2.Should().Be("arg1");
            report.Skip(1).First().Item3.Should().Be(arg1);
            report.Skip(1).First().Item4.Should().BeTrue(); // because type is not string
            report.Skip(1).First().Item5.Should().HaveCount(1);
            report.Skip(1).First().Item5.Should().Contain("Test");
            report.Skip(1).First().Item6.Should().BeSameAs(alwaysBeFalse.Item3);
            report.Skip(2).First().Item1.Should().Be(typeof(double));
            report.Skip(2).First().Item2.Should().Be("arg2");
            report.Skip(2).First().Item3.Should().Be(arg2);
            report.Skip(2).First().Item4.Should().BeTrue();
            report.Skip(2).First().Item5.Should().BeEmpty();
            report.Skip(2).First().Item6.Should().BeSameAs(alwaysBeTrue.Item3);
            report.Skip(3).First().Item1.Should().Be(typeof(double));
            report.Skip(3).First().Item2.Should().Be("arg2");
            report.Skip(3).First().Item3.Should().Be(arg2);
            report.Skip(3).First().Item4.Should().BeTrue(); // because type is not string
            report.Skip(3).First().Item5.Should().HaveCount(1);
            report.Skip(3).First().Item5.Should().Contain("Test");
            report.Skip(3).First().Item6.Should().BeSameAs(alwaysBeFalse.Item3);
            report.Skip(4).First().Item1.Should().Be(typeof(string));
            report.Skip(4).First().Item2.Should().Be("arg3");
            report.Skip(4).First().Item3.Should().Be(arg3);
            report.Skip(4).First().Item4.Should().BeTrue();
            report.Skip(4).First().Item5.Should().BeEmpty();
            report.Skip(4).First().Item6.Should().BeSameAs(alwaysBeTrue.Item3);
            report.Skip(5).First().Item1.Should().Be(typeof(string));
            report.Skip(5).First().Item2.Should().Be("arg3");
            report.Skip(5).First().Item3.Should().Be(arg3);
            report.Skip(5).First().Item4.Should().BeFalse();
            report.Skip(5).First().Item5.Should().HaveCount(1);
            report.Skip(5).First().Item5.Should().Contain("Test");
            report.Skip(5).First().Item6.Should().BeSameAs(alwaysBeFalse.Item3);
        }

        [Test]
        public void GetExceptions_throws_on_null_validation_report_argument()
        {
            Assert.Throws<ArgumentNullException>(() => (null as ValidationReport).GetExceptions());
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_throws_on_null_validation_report_argument()
        {
            Assert.Throws<ArgumentNullException>(() => (null as ValidationReport).GetSingleOrAggregateArgumentException());
        }

        [Test]
        public void GetExceptions_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.Report().GetExceptions().ToList());
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.Report().GetSingleOrAggregateArgumentException());
        }

        [Test]
        public void OrRunWithAll_function_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrRunWithAll(exceptions => "ignored"));
        }

        [Test]
        public void OrRunWithAll_action_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrRunWithAll(exceptions => { }));
        }

        [Test]
        public void OrRunWith_function_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrRunWith(exception => "ignored"));
        }

        [Test]
        public void OrRunWith_action_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrRunWith(exception => { }));
        }

        [Test]
        public void OrRun_function_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(validationPlan => validationPlan.OrRun(() => "ignored"));
        }

        [Test]
        public void OrRun_action_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(validationPlan => validationPlan.OrRun(() => { }));
        }

        [Test]
        public void OrThrowWithAll_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrThrowWithAll(exceptions => null));
        }

        [Test]
        public void OrThrowWith_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrThrowWith(exception => null));
        }

        [Test]
        public void OrThrow_function_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(validationPlan => validationPlan.OrThrow(() => null));
        }

        [Test]
        public void OrThrowOfT_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(
                validationPlan => validationPlan.OrThrow<InvalidOperationException>());
        }

        [Test]
        public void OrThrow_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_does_not_call_GetException_when_validation_succeeds()
        {
            AssertGetExceptionIsNotCalledWhenValidationSucceeds(validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void AssertGetExceptionIsNotCalledWhenValidationSucceeds(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = DateTime.UtcNow;
            float? arg2 = null;

            var called = false;
            var alwaysBeTrue = MakeRule.That<object>(o => true);
            
            var beTrue1 = alwaysBeTrue.OrCreate(
                () =>
                {
                    called = true;
                    return new Exception();
                });

            var beTrue2 = alwaysBeTrue.OrCreate(
                argumentName =>
                {
                    called = true;
                    return new Exception();
                });

            var beTrue3 = alwaysBeTrue.OrCreate(
                (argumentValue, argumentName) =>
                {
                    called = true;
                    return new Exception();
                });

            var beTrue4 = alwaysBeTrue.OrCreate(
                (messages, argumentValue, argumentName) =>
                {
                    called = true;
                    return new Exception();
                });

            var beTrue5 = alwaysBeTrue.OrCreate(
                (type, messages, argumentValue, argumentName) =>
                {
                    called = true;
                    return new Exception();
                });

            runTest(new { arg1, arg2 }.Must(beTrue1));
            runTest(new { arg1, arg2 }.Must(beTrue2));
            runTest(new { arg1, arg2 }.Must(beTrue3));
            runTest(new { arg1, arg2 }.Must(beTrue4));
            runTest(new { arg1, arg2 }.Must(beTrue5));

            called.Should().BeFalse();
        }

        [Test]
        public void GetExceptions_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.Report().GetExceptions().ToList());
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.Report().GetSingleOrAggregateArgumentException());
        }

        [Test]
        public void OrRunWithAll_function_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRunWithAll(exceptions => "ignored"));
        }

        [Test]
        public void OrRunWithAll_action_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRunWithAll(exceptions => { }));
        }

        [Test]
        public void OrRunWith_function_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRunWith(exception => "ignored"));
        }

        [Test]
        public void OrRunWith_action_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRunWith(exception => { }));
        }

        [Test]
        public void OrRun_function_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRun(() => "ignored"));
        }

        [Test]
        public void OrRun_action_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrRun(() => { }));
        }

        [Test]
        public void OrThrowWithAll_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrowWithAll(exceptions => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrowWith_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrowWith(exception => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrow_function_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrow(() => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrowOfT_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrow<ArgumentException>());
        }

        [Test]
        public void OrThrow_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_calls_GetException_with_expected_arguments_when_validation_fails()
        {
            AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(
                validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void AssertGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            string argumentName1 = null;
            string argumentName2 = null;
            string argumentName3 = null;
            string argumentName4 = null;
            object argumentValue2 = null;
            object argumentValue3 = null;
            object argumentValue4 = null;
            IEnumerable<string> messages3 = null;
            IEnumerable<string> messages4 = null;
            Type type4 = null;

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate(
                argumentName =>
                {
                    argumentName1 = argumentName;
                    return new ArgumentException("ignored");
                });

            var beFalse2 = alwaysBeFalse.OrCreate(
                (argumentValue, argumentName) =>
                {
                    argumentName2 = argumentName;
                    argumentValue2 = argumentValue;
                    return new ArgumentException("ignored");
                });

            var beFalse3 = alwaysBeFalse.OrCreate(
                (messages, argumentValue, argumentName) =>
                {
                    argumentName3 = argumentName;
                    argumentValue3 = argumentValue;
                    messages3 = messages;
                    return new ArgumentException("ignored");
                }).Because("Test1");

            var beFalse4 = alwaysBeFalse.OrCreate(
                (type, messages, argumentValue, argumentName) =>
                {
                    argumentName4 = argumentName;
                    argumentValue4 = argumentValue;
                    messages4 = messages;
                    type4 = type;
                    return new ArgumentException("ignored");
                }).Because("Test1").Because("Test2");

            runTest(new { arg1 }.Must(beFalse1));
            runTest(new { arg1 }.Must(beFalse2));
            runTest(new { arg1 }.Must(beFalse3));
            runTest(new { arg1 }.Must(beFalse4));

            argumentName1.Should().Be("arg1");
            argumentName2.Should().Be("arg1");
            argumentName3.Should().Be("arg1");
            argumentName4.Should().Be("arg1");
            argumentValue2.Should().Be("Value");
            argumentValue3.Should().Be("Value");
            argumentValue4.Should().Be("Value");
            messages3.Should().HaveCount(1).And.Contain("Test1");
            messages4.Should().HaveCount(2).And.ContainInOrder("Test1", "Test2");
            type4.Should().Be<string>();
        }

        private void AssertWithThrowGetExceptionIsCalledWithExpectedArgumentsWhenValidationFails(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            string argumentName1 = null;
            string argumentName2 = null;
            string argumentName3 = null;
            string argumentName4 = null;
            object argumentValue2 = null;
            object argumentValue3 = null;
            object argumentValue4 = null;
            IEnumerable<string> messages3 = null;
            IEnumerable<string> messages4 = null;
            Type type4 = null;

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate(
                argumentName =>
                {
                    argumentName1 = argumentName;
                    return new ArgumentException("ignored");
                });

            var beFalse2 = alwaysBeFalse.OrCreate(
                (argumentValue, argumentName) =>
                {
                    argumentName2 = argumentName;
                    argumentValue2 = argumentValue;
                    return new ArgumentException("ignored");
                });

            var beFalse3 = alwaysBeFalse.OrCreate(
                (messages, argumentValue, argumentName) =>
                {
                    argumentName3 = argumentName;
                    argumentValue3 = argumentValue;
                    messages3 = messages;
                    return new ArgumentException("ignored");
                }).Because("Test1");

            var beFalse4 = alwaysBeFalse.OrCreate(
                (type, messages, argumentValue, argumentName) =>
                {
                    argumentName4 = argumentName;
                    argumentValue4 = argumentValue;
                    messages4 = messages;
                    type4 = type;
                    return new ArgumentException("ignored");
                }).Because("Test1").Because("Test2");

            Assert.Throws<ArgumentException>(() => runTest(new { arg1 }.Must(beFalse1)));
            Assert.Throws<ArgumentException>(() => runTest(new { arg1 }.Must(beFalse2)));
            Assert.Throws<ArgumentException>(() => runTest(new { arg1 }.Must(beFalse3)));
            Assert.Throws<ArgumentException>(() => runTest(new { arg1 }.Must(beFalse4)));

            argumentName1.Should().Be("arg1");
            argumentName2.Should().Be("arg1");
            argumentName3.Should().Be("arg1");
            argumentName4.Should().Be("arg1");
            argumentValue2.Should().Be("Value");
            argumentValue3.Should().Be("Value");
            argumentValue4.Should().Be("Value");
            messages3.Should().HaveCount(1).And.Contain("Test1");
            messages4.Should().HaveCount(2).And.ContainInOrder("Test1", "Test2");
            type4.Should().Be<string>();
        }

        [Test]
        public void GetExceptions_is_empty_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.Report().GetExceptions().Should().BeEmpty());
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_is_null_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.Report().GetSingleOrAggregateArgumentException().Should().BeNull());
        }

        [Test]
        public void OrRunWithAll_function_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRunWithAll(exceptions => true));
        }

        [Test]
        public void OrRunWithAll_action_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRunWithAll(exceptions => { throw new InvalidOperationException("Test should not throw"); }));
        }

        [Test]
        public void OrRunWith_function_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRunWith(exception => true));
        }

        [Test]
        public void OrRunWith_action_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRunWith(exception => { throw new InvalidOperationException("Test should not throw"); }));
        }

        [Test]
        public void OrRun_function_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRun(() => true));
        }

        [Test]
        public void OrRun_action_is_not_called_when_GetException_returns_null()
        {
            RunWithGetExceptionReturningNull(
                validationPlan => validationPlan.OrRun(() => { throw new InvalidOperationException("Test should not throw"); }));
        }

        [Test]
        public void OrThrowWithAll_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrowWithAll(exceptions => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrowWith_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrowWith(exception => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrow_function_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrow(() => new ArgumentException("ignored")));
        }

        [Test]
        public void OrThrowOfT_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrow<ArgumentException>());
        }

        [Test]
        public void OrThrow_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_does_not_throw_when_GetException_returns_null()
        {
            AssertDoesNotThrowWhenGetExceptionReturnsNull(
                validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void RunWithGetExceptionReturningNull(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate<object, ArgumentException>(() => null);
            var beFalse2 = alwaysBeFalse.OrCreate<object, ArgumentException>(_ => null);
            var beFalse3 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __) => null);
            var beFalse4 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __, ___) => null);
            var beFalse5 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __, ___, ____) => null);

            runTest(new { arg1 }.Must(beFalse1));
            runTest(new { arg1 }.Must(beFalse2));
            runTest(new { arg1 }.Must(beFalse3));
            runTest(new { arg1 }.Must(beFalse4));
            runTest(new { arg1 }.Must(beFalse5));
        }

        private void AssertDoesNotThrowWhenGetExceptionReturnsNull(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate<object, ArgumentException>(() => null);
            var beFalse2 = alwaysBeFalse.OrCreate<object, ArgumentException>(_ => null);
            var beFalse3 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __) => null);
            var beFalse4 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __, ___) => null);
            var beFalse5 = alwaysBeFalse.OrCreate<object, ArgumentException>((_, __, ___, ____) => null);

            Assert.DoesNotThrow(() => runTest(new { arg1 }.Must(beFalse1)));
            Assert.DoesNotThrow(() => runTest(new { arg1 }.Must(beFalse2)));
            Assert.DoesNotThrow(() => runTest(new { arg1 }.Must(beFalse3)));
            Assert.DoesNotThrow(() => runTest(new { arg1 }.Must(beFalse4)));
            Assert.DoesNotThrow(() => runTest(new { arg1 }.Must(beFalse5)));
        }

        [Test]
        public void GetExceptions_returns_exception_returned_from_GetException_if_only_validation_exception()
        {
            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan =>
                {
                    var exceptions = validationPlan.Report().GetExceptions();

                    exceptions.Should().HaveCount(1).And.Subject.First().Should().BeOfType<TestException>();
                });
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_returns_exception_returned_from_GetException_if_only_validation_exception()
        {
            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan =>
                {
                    var exception = validationPlan.Report().GetSingleOrAggregateArgumentException();

                    exception.Should().BeOfType<TestException>();
                });
        }

        [Test]
        public void OrRunWithAll_function_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRunWithAll(
                    exceptions =>
                    {
                        called = true;
                        exceptions.Should().HaveCount(1).And.Subject.First().Should().BeOfType<TestException>();
                        return called;
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWithAll_action_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRunWithAll(
                    exceptions =>
                    {
                        called = true;
                        exceptions.Should().HaveCount(1).And.Subject.First().Should().BeOfType<TestException>();
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWith_function_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRunWith(
                    exception =>
                    {
                        called = true;
                        exception.Should().BeOfType<TestException>();
                        return called;
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWith_action_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRunWith(
                    exception =>
                    {
                        called = true;
                        exception.Should().BeOfType<TestException>();
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrRun_function_is_called_when_GetException_returns_single_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRun(
                    () =>
                    {
                        called = true;
                        return called;
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrRun_action_is_called_when_GetException_returns_single_validation_exception()
        {
            var called = false;

            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan => validationPlan.OrRun(() => { called = true; }));

            called.Should().BeTrue();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "Allis", Justification = "Code Analysis must be stripping out the _ in the method name to get this error - there is no issue here.")]
        [Test]
        public void OrThrowWithAll_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrowWithAll(
                    exceptions =>
                    {
                        called = true;
                        exceptions.Should().HaveCount(1).And.Subject.First().Should().BeOfType<TestException>();
                        return new TestException();
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrThrowWith_is_called_with_exception_returned_from_GetException_if_only_validation_exception()
        {
            var called = false;

            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrowWith(
                    exception =>
                    {
                        called = true;
                        exception.Should().BeOfType<TestException>();
                        return new TestException();
                    }));

            called.Should().BeTrue();
        }

        [Test]
        public void OrThrow_function_is_called_when_GetException_returns_single_validation_exception()
        {
            var called = false;

            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrow(
                    () =>
                    {
                        called = true;
                        return new TestException();
                    }));

            called.Should().BeTrue();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "Tis", Justification = "Code Analysis must be stripping out the _ in the method name to get this error - there is no issue here.")]
        [Test]
        public void OrThrowOfT_is_called_when_GetException_returns_single_validation_exception()
        {
            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrow<TestException>());
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "OrThrow", Justification = "This is referring to an identifier in code and will be useful when message is read.")]
        [Test]
        public void OrThrowOfT_throws_supplied_exception_containing_exception_returned_from_GetException_if_only_validation_exception()
        {
            RunWithSingleTestExceptionReturnedFromGetException(
                validationPlan =>
                {
                    try
                    {
                        validationPlan.OrThrow<TestException>();
                    }
                    catch (TestException ex)
                    {
                        ex.Should().NotBeNull();
                        ex.InnerException.Should().NotBeNull();
                        ex.InnerException.Should().BeOfType<TestException>();

                        return;
                    }
                    Assert.Fail("Expected OrThrow<T>() to throw but it did not.");
                });
        }

        [Test]
        public void OrThrow_throws_exception_returned_from_GetException_if_only_validation_exception()
        {
            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_throws_exception_returned_from_GetException_if_only_validation_exception()
        {
            AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(
                validationPlan => validationPlan.OrThrowFirstFailure());
        }

        private void RunWithSingleTestExceptionReturnedFromGetException(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate(() => new TestException());
            var beFalse2 = alwaysBeFalse.OrCreate(_ => new TestException());
            var beFalse3 = alwaysBeFalse.OrCreate((_, __) => new TestException());
            var beFalse4 = alwaysBeFalse.OrCreate((_, __, ___) => new TestException());
            var beFalse5 = alwaysBeFalse.OrCreate((_, __, ___, ____) => new TestException());

            runTest(new { arg1 }.Must(beFalse1));
            runTest(new { arg1 }.Must(beFalse2));
            runTest(new { arg1 }.Must(beFalse3));
            runTest(new { arg1 }.Must(beFalse4));
            runTest(new { arg1 }.Must(beFalse5));
        }

        private void AssertThrowsExceptionReturnedFromGetExceptionIfOnlyValidationException(Action<Tuple<GetArguments, IEnumerable<Rule>>> runTest)
        {
            var arg1 = "Value";

            var alwaysBeFalse = MakeRule.That<object>(o => false);

            var beFalse1 = alwaysBeFalse.OrCreate(() => new TestException());
            var beFalse2 = alwaysBeFalse.OrCreate(_ => new TestException());
            var beFalse3 = alwaysBeFalse.OrCreate((_, __) => new TestException());
            var beFalse4 = alwaysBeFalse.OrCreate((_, __, ___) => new TestException());
            var beFalse5 = alwaysBeFalse.OrCreate((_, __, ___, ____) => new TestException());

            Assert.Throws<TestException>(() => runTest(new { arg1 }.Must(beFalse1)));
            Assert.Throws<TestException>(() => runTest(new { arg1 }.Must(beFalse2)));
            Assert.Throws<TestException>(() => runTest(new { arg1 }.Must(beFalse3)));
            Assert.Throws<TestException>(() => runTest(new { arg1 }.Must(beFalse4)));
            Assert.Throws<TestException>(() => runTest(new { arg1 }.Must(beFalse5)));
        }

        [Test]
        public void GetExceptions_returns_all_failed_exceptions_when_multiple_validations_fail()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            var exceptions = validationPlan.Report().GetExceptions().ToList();

            AssertTwoFailureValidationPlanExceptions(exceptions);
        }

        [Test]
        public void GetSingleOrAggregateArgumentException_returns_ArgumentException_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            var exception = validationPlan.Report().GetSingleOrAggregateArgumentException();

            AssertTwoFailureValidationPlanAggregateArgumentException(exception);
        }

        [Test]
        public void OrRunWithAll_function_is_called_with_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRunWithAll(
                exceptions =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanExceptions(exceptions.ToList());
                    return called;
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWithAll_action_is_called_with_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRunWithAll(
                exceptions =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanExceptions(exceptions.ToList());
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWith_function_is_called_with_ArgumentException_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRunWith(
                exception =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanAggregateArgumentException(exception);
                    return called;
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrRunWith_action_is_called_with_ArgumentException_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRunWith(
                exception =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanAggregateArgumentException(exception);
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrRun_function_is_called_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRun(
                () =>
                {
                    called = true;
                    return called;
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrRun_action_is_called_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrRun(() => { called = true; });

            called.Should().BeTrue();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "Allis", Justification = "Code Analysis must be stripping out the _ in the method name to get this error - there is no issue here.")]
        [Test]
        public void OrThrowWithAll_is_called_with_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrowWithAll(
                exceptions =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanExceptions(exceptions.ToList());
                    return null;
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrThrowWith_is_called_with_ArgumentException_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrowWith(
                exception =>
                {
                    called = true;
                    AssertTwoFailureValidationPlanAggregateArgumentException(exception);
                    return null;
                });

            called.Should().BeTrue();
        }

        [Test]
        public void OrThrow_function_is_called_when_multiple_validations_fail()
        {
            var called = false;
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrow(
                () =>
                {
                    called = true;
                    return null;
                });

            called.Should().BeTrue();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "OrThrow", Justification = "This is referring to an identifier in code and will be useful when message is read.")]
        [Test]
        public void OrThrowOfT_throws_supplied_exception_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            try
            {
                validationPlan.OrThrow<TestException>();
            }
            catch (TestException ex)
            {
                ex.Should().NotBeNull();
                ex.InnerException.Should().NotBeNull();
                ex.InnerException.Should().BeOfType<AggregateException>();
                (ex.InnerException as AggregateException).InnerExceptions.Should().HaveCount(2);
                (ex.InnerException as AggregateException).InnerExceptions.First()
                    .Should().BeOfType<ArgumentException>();
                (ex.InnerException as AggregateException).InnerExceptions.First()
                    .GetType()
                    .Should()
                    .NotBe<ArgumentNullException>();
                (ex.InnerException as AggregateException).InnerExceptions.Skip(1).First()
                    .Should().BeOfType<ArgumentNullException>();

                return;
            }

            Assert.Fail("Expected OrThrow<T>() to throw but it did not.");
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "OrThrow", Justification = "This is referring to an identifier in code and will be useful when message is read.")]
        [Test]
        public void OrThrow_throws_ArgumentException_containing_all_failed_exceptions_when_multiple_validations_fail()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            try
            {
                validationPlan.OrThrow();
            }
            catch (ArgumentException ex)
            {
                AssertTwoFailureValidationPlanAggregateArgumentException(ex);

                return;
            }

            Assert.Fail("Expected OrThrow() to throw but it did not.");
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1820:TestForEmptyStringsUsingStringLength", Justification = "Test is designed to only check empty and not null or emtpy.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "OrThrowFirstFailure", Justification = "This is referring to an identifier in code and will be useful when message is read.")]
        [Test]
        public void OrThrowFirstFailure_throws_first_exception_returned_from_GetException_when_multiple_validations_fail()
        {
            string arg1 = null;
            var arg2 = string.Empty;

            var notBeNull = MakeRule.That<object>(o => o != null).OrCreateArgumentNullException();
            var notBeEmpty = MakeRule.That<string>(s => s != string.Empty).OrCreateArgumentException();

            var validationPlan = new { arg1, arg2 }.Must(notBeNull, notBeEmpty);

            try
            {
                validationPlan.OrThrowFirstFailure();
            }
            catch (ArgumentNullException ex)
            {
                ex.InnerException.Should().BeNull();

                return;
            }

            Assert.Fail("Expected OrThrowFirstFailure() to throw but it did not.");
        }

        private Tuple<GetArguments, IEnumerable<Rule>> GetTwoFailureValidationPlan()
        {
            var arg1 = "Value";
            int? arg2 = null;

            var notBeNull = MakeRule.That<object>(o => o != null).OrCreateArgumentNullException();
            var notBeEqualToValue = MakeRule.That<string>(s => s != "Value").OrCreateArgumentException();

            var validationPlan = new { arg1, arg2 }.Must(notBeNull, notBeEqualToValue);

            return validationPlan;
        }

        private void AssertTwoFailureValidationPlanExceptions(IReadOnlyCollection<Exception> exceptions)
        {
            exceptions.Should().NotBeNull();
            exceptions.Should().HaveCount(2);
            exceptions.First().Should().BeOfType<ArgumentException>();
            exceptions.First().GetType().Should().NotBe<ArgumentNullException>();
            exceptions.Skip(1).First().Should().BeOfType<ArgumentNullException>();
        }

        private void AssertTwoFailureValidationPlanAggregateArgumentException(Exception exception)
        {
            exception.Should().NotBeNull();
            exception.Should().BeOfType<ArgumentException>();
            exception.GetType().Should().NotBe<ArgumentNullException>();
            exception.InnerException.Should().NotBeNull();
            exception.InnerException.Should().BeOfType<AggregateException>();
            (exception.InnerException as AggregateException).InnerExceptions.Should().HaveCount(2);
            (exception.InnerException as AggregateException).InnerExceptions.First()
                .Should().BeOfType<ArgumentException>();
            (exception.InnerException as AggregateException).InnerExceptions.First()
                .GetType()
                .Should()
                .NotBe<ArgumentNullException>();
            (exception.InnerException as AggregateException).InnerExceptions.Skip(1).First()
                .Should().BeOfType<ArgumentNullException>();
        }

        [Test]
        public void OrRunWithAll_function_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRunWithAll(exceptions => exceptions));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRunWithAll(null as Func<IEnumerable<Exception>, object>));
        }

        [Test]
        public void OrRunWithAll_action_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRunWithAll(exceptions => { }));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRunWithAll(null as Action<IEnumerable<Exception>>));
        }

        [Test]
        public void OrRunWith_function_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRunWith(exception => exception));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRunWith(null as Func<Exception, object>));
        }

        [Test]
        public void OrRunWith_action_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRunWith(exception => { }));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRunWith(null as Action<Exception>));
        }

        [Test]
        public void OrRun_function_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRun(() => true));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRun(null as Func<object>));
        }

        [Test]
        public void OrRun_action_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrRun(() => { }));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrRun(null as Action));
        }

        [Test]
        public void OrThrowWithAll_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrowWithAll(exceptions => null));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrThrowWithAll(null as Func<IEnumerable<Exception>, Exception>));
        }

        [Test]
        public void OrThrowWith_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrowWith(exception => null));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrThrowWith(null as Func<Exception, Exception>));
        }

        [Test]
        public void OrThrow_function_throws_on_null_arguments()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrow(() => null));
            Assert.Throws<ArgumentNullException>(() => validationPlan.OrThrow(null as Func<Exception>));
        }

        [Test]
        public void OrThrowOfT_throws_on_null_arguments()
        {
            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrow<TestException>());
        }

        [Test]
        public void OrThrow_throws_on_null_arguments()
        {
            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrow());
        }

        [Test]
        public void OrThrowFirstFailure_throws_on_null_arguments()
        {
            Assert.Throws<ArgumentNullException>(() => (null as Tuple<GetArguments, IEnumerable<Rule>>).OrThrowFirstFailure());
        }

        private static Tuple<GetArguments, IEnumerable<Rule>> GetAlwaysValidValiationPlan()
        {
            var arg = "value";
            var alwaysBeTrue = MakeRule.That<object>(o => true).OrCreateArgumentException();
            var validationPlan = new { arg }.Must(alwaysBeTrue);

            return validationPlan;
        }

        [Test]
        public void OrRunWithAll_function_returns_default_T_when_there_are_no_validation_failures()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            var result = validationPlan.OrRunWithAll(exceptions => DateTime.UtcNow);

            result.Should().Be(default(DateTime));
        }

        [Test]
        public void OrRunWith_function_returns_default_T_when_there_are_no_validation_failures()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            var result = validationPlan.OrRunWith(exception => TimeSpan.FromDays(5));

            result.Should().Be(default(TimeSpan));
        }

        [Test]
        public void OrRun_function_returns_default_T_when_there_are_no_validation_failures()
        {
            var validationPlan = GetAlwaysValidValiationPlan();

            var result = validationPlan.OrRun(() => Guid.NewGuid());

            result.Should().Be(default(Guid));
        }

        [Test]
        public void OrRunWithAll_function_returns_result_of_call_when_there_are_validation_failures()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            var result = validationPlan.OrRunWithAll(exceptions => 590);

            result.Should().Be(590);
        }

        [Test]
        public void OrRunWith_function_returns_result_of_call_when_there_are_validation_failures()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            var result = validationPlan.OrRunWith(exception => 6.1);

            result.Should().Be(6.1);
        }

        [Test]
        public void OrRun_function_returns_result_of_call_when_there_are_validation_failures()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            var result = validationPlan.OrRun(() => TimeSpan.FromMinutes(10));

            result.Should().Be(TimeSpan.FromMinutes(10));
        }

        [Test]
        public void OrThrowWithAll_does_not_throw_when_call_returns_null()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrowWithAll(exceptions => null);
        }

        [Test]
        public void OrThrowWith_does_not_throw_when_call_returns_null()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrowWith(exception => null);
        }

        [Test]
        public void OrThrow_function_does_not_throw_when_call_returns_null()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            validationPlan.OrThrow(() => null);
        }

        [Test]
        public void OrThrowWithAll_overrides_any_validation_failure_exceptions_with_returned_exception()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            Assert.Throws<TestException>(() => validationPlan.OrThrowWithAll(exceptions => new TestException()));
        }

        [Test]
        public void OrThrowWith_overrides_any_validation_failure_exceptions_with_returned_exception()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            Assert.Throws<TestException>(() => validationPlan.OrThrowWith(exception => new TestException()));
        }

        [Test]
        public void OrThrow_function_overrides_any_validation_failure_exceptions_with_returned_exception()
        {
            var validationPlan = GetTwoFailureValidationPlan();

            Assert.Throws<TestException>(() => validationPlan.OrThrow(() => new TestException()));
        }

        [Serializable]
        private class TestException : Exception
        {
        }
    }
}
