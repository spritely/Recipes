// --------------------------------------------------------------------------------------------------------------------
// <copyright file="RuleExtensions.cs">
//     Copyright (c) 2016. All rights reserved. Licensed under the MIT license. See LICENSE file in
//     the project root for full license information.
// </copyright>
// <auto-generated>
// Sourced from NuGet package. Will be overwritten with package update except in Spritely.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Recipes
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    // See MustExtensions.cs for comments on type definitions
    using GetArguments = System.Func<System.Collections.Generic.IEnumerable<System.Tuple<System.Type, string, object>>>;
    using Rule = System.Tuple<System.Func<System.Type, object, bool>, System.Collections.Generic.IEnumerable<string>, System.Func<System.Type, System.Collections.Generic.IEnumerable<string>, object, string, System.Exception>>;

    /// <summary>
    ///     Contains built-in extensions for Must Rules.
    /// </summary>
#if !RecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal static partial class RuleExtensions
    {
        public static Tuple<GetArguments, IEnumerable<Rule>> ValidateArgumentAndAppendRule(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, params Rule[] rules)
        {
            if (validationReportDefinition == null)
            {
                throw new ArgumentNullException("validationReportDefinition");
            }

            if (rules == null)
            {
                throw new ArgumentNullException("rules");
            }

            if (rules.Length < 1)
            {
                throw new ArgumentException("ValidateArgumentAndAppendRule requires at least 1 rule to append.");
            }

            var result = Tuple.Create(
                validationReportDefinition.Item1,
                validationReportDefinition.Item2.Concat(rules));

            return result;
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotNull(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotNull);
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotNullOrEmptyString(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotNullOrEmptyString);
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotNullOrWhiteSpace(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotNullOrWhiteSpace);
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotEmptyGuid(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotEmptyGuid);
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotNullOrEmptyEnumerable<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotNullOrEmptyEnumerable<T>());
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> NotNullOrContainAnyNulls<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition)
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.NotNullOrContainAnyNulls<T>());
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> InRange<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, T minimum, T maximum)
            where T : IComparable
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.InRange(minimum, maximum));
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> LessThan<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, T requirement)
            where T : IComparable
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.LessThan(requirement));
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> LessThanOrEqualTo<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, T requirement)
            where T : IComparable
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.LessThanOrEqualTo(requirement));
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> GreaterThan<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, T requirement)
            where T : IComparable
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.GreaterThan(requirement));
        }

        public static Tuple<GetArguments, IEnumerable<Rule>> GreaterThanOrEqualTo<T>(this Tuple<GetArguments, IEnumerable<Rule>> validationReportDefinition, T requirement)
            where T : IComparable
        {
            return ValidateArgumentAndAppendRule(validationReportDefinition, Rules.GreaterThanOrEqualTo(requirement));
        }
    }
#if !RecipesProject
#pragma warning restore 0436
#endif
}
